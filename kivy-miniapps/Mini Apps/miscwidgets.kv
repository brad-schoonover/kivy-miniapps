#Start of the MiniApp MiscWidgets.py Kivy file
#------------------------------------------------------------------------------ = end of a particular screen
#Screen of the DropDown

<DropDowns>:
	id: drop

#assigns top_layout (which is used in the python file), to the topLayout that is defined lower in this file

    top_layout: topLayout

	FloatLayout:
	
#like in the last MiniApp we set up the buttons to transition between the screens
	
		BoxLayout:
		
			orientation:'horizontal'
			size: 300, 50 
			size_hint:'None', 'None'
			pos:200, 400
			
    		Button:
        		text: 'CheckBoxes'
        		on_press: root.manager.current = 'check'

    		Button:
        		text: 'Sliders'
        		on_press: root.manager.current = 'slide'
        		
			Button:
        		text: 'Switches'
        		on_press: root.manager.current = 'switch'
 
 #This BoxLayout is used to create the topLayout, so that it is pressed on top of the app window       		

    BoxLayout:
    
        id: topLayout
        #cols: 2
        size_hint: 1, .05
        pos_hint: {'x': 0, 'y': .95}
        
#This is the main button that will drop the kivy dropdown menu, with the use of on_release attribute
#the drop_down.open was assigned in the python file to the customdropdown
        
        Button:
        
            id: btn_dd
            text: 'DropDown_Kv'
            on_release: root.drop_down.open(self)

#the CustomDropDown is the kivy design of the drop down with a button, label, button order

<CustomDropDown>:

    Button:
    
        text: 'My first Item'
        size_hint_y: None
        height: 44
        on_release: root.select('item1')
 
 #the label is used for a item that can't be selected in the dropdown menu for it is not a button (makes sense right?)
        
    Label:
    
        text: 'Unselectable item'
        size_hint_y: None
        height: 44
        
    Button:
    
        text: 'My second Item'
        size_hint_y: None
        height: 44
        on_release: root.select('item2')
#--------------------------------------------------------------------
#start of CheckBoxes screen

<CheckBoxes>:

	FloatLayout:

#Buttons for the screen management 
	
		BoxLayout:
		
			orientation:'horizontal'
			size:300, 50 
			size_hint:'None', 'None'
			pos:200, 500
			
    		Button:
        		text: 'DropDown'
        		on_press: root.manager.current = 'drop'

    		Button:
        		text: 'Sliders'
        		on_press: root.manager.current = 'slide'
        		
			Button:
        		text: 'Switches'
        		on_press: root.manager.current = 'switch'
        		
#Creates a 3 column grid that fills in the order of label followed by 2 CheckBoxes, once filled it will move on to a new row
	
		GridLayout:

			cols: 3
			spacing: '8dp'
			size_hint: .5, None
			height: self.minimum_height

			Label:
				text: 'Checkbox'

			CheckBox:
				size_hint_y: None
				height: '48dp'

			CheckBox:
				size_hint_y: None
				height: '48dp'

			Label:
				text: 'CheckBox with group'
			
			CheckBox:
				size_hint_y: None
				height: '48dp'
				
#The group attribute links the checkboxes together that will changes the selection of one when they other is pressed		

				group: 'Grouped'
			
			CheckBox:
				size_hint_y: None
				height: '48dp'
				group: 'Grouped'
				
#-----------------------------------------------------------------
#Start of Sliders screen  
       	
<Sliders>:

	FloatLayout:

#transitions between screens
	
		BoxLayout:
			orientation:'horizontal'
			size:300, 50 
			size_hint:'None', 'None'
			pos:50, 500
			
    		Button:
        		text: 'DropDown'
        		on_press: root.manager.current = 'drop'

    		Button:
        		text: 'CheckBoxes'
        		on_press: root.manager.current = 'check'
        		
			Button:
        		text: 'Switches'
        		on_press: root.manager.current = 'switch'
        		
# the first slider is a horizontal slider with a label that updates to the value of the slider
         		
	BoxLayout:
        	
		size_hint_y: None
		
#this '48dp' is a different sizing method, that depends on the dpi of the screen the application runs on. px = dp*(dpi/160)
	
		height: '48dp'
		pos: 50, 300
			
		Label:
			text: 'Default'
				
		Slider:
			id: s1
				
		Label:
		
#updates the label
		
			text: '{}'.format(s1.value)

#This boxlayout holds the horizontal stepped slider that moves in whole values at increments of 2 
				
	BoxLayout:
			
		size_hint_y: None
		height: '48dp'
		pos: 50, 200
				
		Label:
				
			text: 'Stepped'
				
		Slider:
				
			id: s2
			
#stepping attribute
			
			step: 2
				
		Label:
				
			text: '{}'.format(s2.value)
			
#this combo AnchorLayout and Gridlayout sets 2 columns for vertical sliders that have the equal values to the previous sliders we defined 
				
	AnchorLayout:
			
		size_hint_y: None
		height: '100dp'
		pos: 10, 350
				
		GridLayout:
				
			cols: 2
			spacing: '8dp'
			size_hint_x: None
			width: self.minimum_width

#this slider is equal to the default slider 
					
			Slider:
					
				size_hint_x: None
				width: '48dp'
				orientation: 'vertical'
				value: s1.value
				on_value: s1.value = self.value

#this slider is equal to the stepped slider
					
			Slider:
				
				size_hint_x: None
				width: '48dp'
				orientation: 'vertical'
				step: 2
				value: s2.value
				on_value: s2.value = self.value

#customized slider
	BoxLayout:
		size_hint: .2, .2
		pos_hint: {'x': .7, 'y': .7}
			
		MySlider:
			id: sc
			orientation: 'vertical'
			on_value: sc.value = self.value
		
		Label:
			text: '{}'.format(sc.value)
			
	BoxLayout
		size_hint: .05, .05
		pos_hint: {'x': .75, 'y': .9}
		
		Label:
			text: 'Custom Slider'
#-----------------------------------------------------------------
#Start of Switches Screen
        		
<Switches>:

	FloatLayout:

#screen Transitions
	
		BoxLayout:
		
			orientation:'horizontal'
			size:300, 50 
			size_hint:'None', 'None'
			pos:200, 500
			
    		Button:
        		text: 'DropDown'
        		on_press: root.manager.current = 'drop'

    		Button:
        		text: 'CheckBoxes'
        		on_press: root.manager.current = 'check'
        		
			Button:
        		text: 'Sliders'
        		on_press: root.manager.current = 'slide'
        		
#The Switches are very straight forword, in the fact that you can set active or off with True/False commands
#and disable or enable the switches with commands.

	BoxLayout:
		size_hint_y: None
		height: '48dp'
		pos: 50, 400
		
		Label:
			text: 'Switch normal'
			
		Switch:
		
	BoxLayout:
		size_hint_y: None
		height: '48dp'
		pos: 50, 350
		
		Label:
			text: 'Switch active'
			
		Switch:
			active: True
		
	BoxLayout:
	
		size_hint_y: None
		height: '48dp'
		pos: 50, 300
		
		Label:
			text: 'Switch off & disabled'
			
		Switch:
			disabled: True
			active: False
		

#If you want to override a pre-made kivy function. You start out by with your open carets and then write out a -, then the name you want, and then type @ (originally name of the function).
#The dash tells they program that you should use this code instead of the original code

<-MySlider@Slider>:
	canvas:
        Color:
            rgb: 1, 1, 1
		#This sets the variables that are taken in to set up which way the slider will face. Inside border image you can change the size and image of the background. 
        BorderImage:
			#tells kivy the dimension to be horizontal or vertical
            border: (0, 18, 0, 18) if self.orientation == 'horizontal' else (18, 0, 18, 0) 
			#this tells kivy where to put in it on the screen.
            pos: (self.x + self.padding, self.center_y - sp(18)) if self.orientation == 'horizontal' else (self.center_x - 18, self.y + self.padding)
			#this code is in charge of the background size and spacing.
            size: (self.width - self.padding * 2, sp(36)) if self.orientation == 'horizontal' else (sp(36), self.height - self.padding * 2) 
			#where and what picture to use. Hey you can change this to be what ever you want, and change the size of the image. This is just a basic example/rectangle
            source: 'slider_background.png'.format(self.orientation[0], '_disabled' if self.disabled else '') 
        Rectangle:
			#this puts the start of the cursor on the slider
            pos: (self.value_pos[0] - sp(16), self.center_y - sp(17)) if self.orientation == 'horizontal' else (self.center_x - (16), self.value_pos[1] - sp(16))
			#spacing of the slider in orientation to the slider it self			
            size: (sp(32), sp(32)) 
			#the image of the cursor and and where the image is
            source: 'Slider_cursor.png'.format('_disabled' if self.disabled else '') 
